{"ast":null,"code":"import Stripe from \"stripe\";\nconst stripe = new Stripe(process.env.REACT_APP_SECRET_KEY);\nexport default async function Pay(req, res) {\n  if (req.method === \"POST\") {\n    console.log(\"1\");\n\n    try {\n      const {\n        amount\n      } = req.body; // Psst. For production-ready applications we recommend not using the\n      // amount directly from the client without verifying it first. This is to\n      // prevent bad actors from changing the total amount on the client before\n      // it gets sent to the server. A good approach is to send the quantity of\n      // a uniquely identifiable product and calculate the total price server-side.\n      // Then, you would only fulfill orders using the quantity you charged for.\n\n      const paymentIntent = await stripe.paymentIntents.create({\n        amount,\n        currency: \"usd\"\n      });\n      res.status(200).send(paymentIntent.client_secret);\n    } catch (err) {\n      res.status(500).json({\n        statusCode: 500,\n        message: err.message\n      });\n    }\n  } else {\n    console.log(\"30\");\n    res.setHeader(\"Allow\", \"POST\");\n    res.status(405).end(\"Method Not Allowed\");\n  }\n}\n;","map":{"version":3,"sources":["/Users/simonsundin/Documents/GitHub/projekt_gr-n/src/ordering_components/api/payment_intents.js"],"names":["Stripe","stripe","process","env","REACT_APP_SECRET_KEY","Pay","req","res","method","console","log","amount","body","paymentIntent","paymentIntents","create","currency","status","send","client_secret","err","json","statusCode","message","setHeader","end"],"mappings":"AAAA,OAAOA,MAAP,MAAmB,QAAnB;AAGA,MAAMC,MAAM,GAAG,IAAID,MAAJ,CAAWE,OAAO,CAACC,GAAR,CAAYC,oBAAvB,CAAf;AAEA,eAAe,eAAeC,GAAf,CAAoBC,GAApB,EAAyBC,GAAzB,EAA8B;AAC3C,MAAID,GAAG,CAACE,MAAJ,KAAe,MAAnB,EAA2B;AACzBC,IAAAA,OAAO,CAACC,GAAR,CAAY,GAAZ;;AAEA,QAAI;AACF,YAAM;AAAEC,QAAAA;AAAF,UAAaL,GAAG,CAACM,IAAvB,CADE,CAEF;AACA;AACA;AACA;AACA;AACA;;AAEA,YAAMC,aAAa,GAAG,MAAMZ,MAAM,CAACa,cAAP,CAAsBC,MAAtB,CAA6B;AACvDJ,QAAAA,MADuD;AAEvDK,QAAAA,QAAQ,EAAE;AAF6C,OAA7B,CAA5B;AAKAT,MAAAA,GAAG,CAACU,MAAJ,CAAW,GAAX,EAAgBC,IAAhB,CAAqBL,aAAa,CAACM,aAAnC;AACD,KAfD,CAeE,OAAOC,GAAP,EAAY;AACZb,MAAAA,GAAG,CAACU,MAAJ,CAAW,GAAX,EAAgBI,IAAhB,CAAqB;AAAEC,QAAAA,UAAU,EAAE,GAAd;AAAmBC,QAAAA,OAAO,EAAEH,GAAG,CAACG;AAAhC,OAArB;AACD;AACF,GArBD,MAqBO;AACLd,IAAAA,OAAO,CAACC,GAAR,CAAY,IAAZ;AAEAH,IAAAA,GAAG,CAACiB,SAAJ,CAAc,OAAd,EAAuB,MAAvB;AACAjB,IAAAA,GAAG,CAACU,MAAJ,CAAW,GAAX,EAAgBQ,GAAhB,CAAoB,oBAApB;AACD;AACF;AAAA","sourcesContent":["import Stripe from \"stripe\";\n\n\nconst stripe = new Stripe(process.env.REACT_APP_SECRET_KEY);\n\nexport default async function Pay (req, res) {\n  if (req.method === \"POST\") {\n    console.log(\"1\")\n\n    try {\n      const { amount } = req.body;\n      // Psst. For production-ready applications we recommend not using the\n      // amount directly from the client without verifying it first. This is to\n      // prevent bad actors from changing the total amount on the client before\n      // it gets sent to the server. A good approach is to send the quantity of\n      // a uniquely identifiable product and calculate the total price server-side.\n      // Then, you would only fulfill orders using the quantity you charged for.\n\n      const paymentIntent = await stripe.paymentIntents.create({\n        amount,\n        currency: \"usd\"\n      });\n\n      res.status(200).send(paymentIntent.client_secret);\n    } catch (err) {\n      res.status(500).json({ statusCode: 500, message: err.message });\n    }\n  } else {\n    console.log(\"30\")\n\n    res.setHeader(\"Allow\", \"POST\");\n    res.status(405).end(\"Method Not Allowed\");\n  }\n};\n"]},"metadata":{},"sourceType":"module"}